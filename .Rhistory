LL2 <- lapply(1:ncol(NOM), function(x) B2 * NOM[keep,
x])
B2 <- do.call(cbind, LL2)
}
nbeta <- NCOL(X) - 1
if (nbeta > 0) {
if (control$sign.location == "negative")
X <- -X
B1 <- cbind(B1, X[keep, -1, drop = FALSE])
B2 <- cbind(B2, X[keep, -1, drop = FALSE])
}
dimnames(B1) <- NULL
dimnames(B2) <- NULL
n.psi <- ncol(B1)
sigma <- Soff <- if (is.null(S.offset))
rep(1, n)
else exp(S.offset[keep])
k <- 0
if (!is.null(S)) {
S <- S[keep, -1, drop = FALSE]
dimnames(S) <- NULL
k <- ncol(S)
}
has.scale <- (!is.null(S) || any(S.offset != 0))
fitted <- numeric(length = n)
wts <- weights[keep]
lst <- namedList(B1, B2, o1, o2, n.psi, S, Soff, k, sigma,
has.scale, fitted, wts, clm.nll, clm.grad, clm.hess)
list2env(x = lst, parent = parent)
}
rho <- with(frames, {
clm.newRho(parent.frame(), y = y, X = X, weights = wts,
offset = off, tJac = ths$tJac)
})
getAnywhere(namedList)
getAnywhere(namedList)[2]
namedList <- function (...)
{
setNames(list(...), nm = sapply(as.list(match.call()), deparse)[-1])
}
rho <- with(frames, {
clm.newRho(parent.frame(), y = y, X = X, weights = wts,
offset = off, tJac = ths$tJac)
})
getAnywhere(clm.nll)
{
if (!missing(par))
rho$par <- par
with(rho, {
if (k > 0)
sigma <- Soff * exp(drop(S %*% par[n.psi + 1:k]))
eta1 <- (drop(B1 %*% par[1:n.psi]) + o1)/sigma
eta2 <- (drop(B2 %*% par[1:n.psi]) + o2)/sigma
})
rho$fitted <- getFittedC(rho$eta1, rho$eta2, rho$link, rho$par[length(rho$par)])
if (all(is.finite(rho$fitted)) && all(rho$fitted > 0))
-sum(rho$wts * log(rho$fitted))
else Inf
}
clm.nll <- function (rho, par)
{
if (!missing(par))
rho$par <- par
with(rho, {
if (k > 0)
sigma <- Soff * exp(drop(S %*% par[n.psi + 1:k]))
eta1 <- (drop(B1 %*% par[1:n.psi]) + o1)/sigma
eta2 <- (drop(B2 %*% par[1:n.psi]) + o2)/sigma
})
rho$fitted <- getFittedC(rho$eta1, rho$eta2, rho$link, rho$par[length(rho$par)])
if (all(is.finite(rho$fitted)) && all(rho$fitted > 0))
-sum(rho$wts * log(rho$fitted))
else Inf
}
rho <- with(frames, {
clm.newRho(parent.frame(), y = y, X = X, weights = wts,
offset = off, tJac = ths$tJac)
})
getAnywhere(clm.grad)
clm.grad <- function (rho)
{
with(rho, {
p1 <- if (!nlambda)
dfun(eta1)
else dfun(eta1, lambda)
p2 <- if (!nlambda)
dfun(eta2)
else dfun(eta2, lambda)
wtpr <- wts/fitted
C2 <- B1 * p1/sigma - B2 * p2/sigma
if (k <= 0)
return(-crossprod(C2, wtpr))
C3 <- -(eta1 * p1 - eta2 * p2) * S
return(-crossprod(cbind(C2, C3), wtpr))
})
}
rho <- with(frames, {
clm.newRho(parent.frame(), y = y, X = X, weights = wts,
offset = off, tJac = ths$tJac)
})
getAnywhere(clm.hess)
clm.hess <-
function (rho)
{
with(rho, {
g1 <- if (!nlambda)
gfun(eta1)
else gfun(eta1, lambda)
g2 <- if (!nlambda)
gfun(eta2)
else gfun(eta2, lambda)
wtprpr <- wtpr/fitted
dg.psi <- crossprod(B1 * g1 * wtpr/sigma^2, B1) - crossprod(B2 *
g2 * wtpr/sigma^2, B2)
D <- dg.psi - crossprod(C2, (C2 * wtprpr))
if (k <= 0)
return(-D)
wtprsig <- wtpr/sigma
epg1 <- p1 + g1 * eta1
epg2 <- p2 + g2 * eta2
Et <- crossprod(B1, -wtprsig * epg1 * S) - crossprod(B2,
-wtprsig * epg2 * S) - crossprod(C2, wtprpr * C3)
F <- -crossprod(S, wtpr * ((eta1 * p1 - eta2 * p2)^2/fitted -
(eta1 * epg1 - eta2 * epg2)) * S)
H <- rbind(cbind(D, Et), cbind(t(Et), F))
return(-H)
})
}
rho <- with(frames, {
clm.newRho(parent.frame(), y = y, X = X, weights = wts,
offset = off, tJac = ths$tJac)
})
retrms <- getREterms(frames = frames, formulae$formula)
getAnywhere(getREterms)
getREterms <- function (frames, formula)
{
fullmf <- droplevels(with(frames, mf[wts > 0, ]))
barlist <- expandSlash(findbars(formula[[3]]))
if (!length(barlist))
stop("No random effects terms specified in formula")
term.names <- unlist(lapply(barlist, deparse))
names(barlist) <- unlist(lapply(barlist, function(x) deparse(x[[3]])))
rel <- lapply(barlist, function(x) {
ff <- eval(substitute(as.factor(fac)[, drop = TRUE],
list(fac = x[[3]])), fullmf)
Zti <- as(ff, "sparseMatrix")
mm <- model.matrix(eval(substitute(~expr, list(expr = x[[2]]))),
fullmf)
Zt = do.call(rbind, lapply(seq_len(ncol(mm)), function(j) {
Zti@x <- mm[, j]
Zti
}))
ST <- matrix(0, ncol(mm), ncol(mm), dimnames = list(colnames(mm),
colnames(mm)))
list(f = ff, Zt = Zt, ST = ST)
})
q <- sum(sapply(rel, function(x) nrow(x$Zt)))
ssr <- (length(barlist) == 1 && as.character(barlist[[1]][[2]]) ==
"1")
nlev <- sapply(rel, function(re) nlevels(re$f))
if (any(diff(nlev)) > 0)
rel <- rel[rev(order(nlev))]
nlev <- nlev[rev(order(nlev))]
retrms <- lapply(rel, "[", -1)
names(retrms) <- term.names
gfl <- lapply(rel, "[[", "f")
attr(gfl, "assign") <- seq_along(gfl)
fnms <- names(gfl)
if (length(fnms) > length(ufn <- unique(fnms))) {
gfl <- gfl[match(ufn, fnms)]
attr(gfl, "assign") <- match(fnms, ufn)
names(gfl) <- ufn
}
stopifnot(all(sapply(gfl, is.factor)))
stopifnot(all(sapply(gfl, nlevels) > 2))
qi <- unlist(lapply(rel, function(re) ncol(re$ST)))
stopifnot(q == sum(nlev * qi))
dims <- list(n = nrow(fullmf), nlev.re = nlev, nlev.gf = sapply(gfl,
nlevels), qi = qi, nretrms = length(rel), ngf = length(gfl),
q = sum(nlev * qi), nSTpar = sum(sapply(qi, function(q) q *
(q + 1)/2)))
list(retrms = retrms, gfList = gfl, dims = dims, ssr = ssr)
}
retrms <- getREterms(frames = frames, formulae$formula)
getAnywhere(expandSlash)
expandSlash <- function (bb)
{
if (!is.list(bb))
return(expandSlash(list(bb)))
unlist(lapply(bb, function(x) {
if (length(x) > 2 && is.list(trms <- slashTerms(x[[3]])))
return(lapply(unlist(makeInteraction(trms)), function(trm) substitute(foo |
bar, list(foo = x[[2]], bar = trm))))
x
}))
}
retrms <- getREterms(frames = frames, formulae$formula)
getAnywhere(findbars)
getAnywhere(findbars)[2]
findbars <- function (term)
{
if (is.name(term) || !is.language(term))
return(NULL)
if (term[[1]] == as.name("("))
return(findbars(term[[2]]))
if (!is.call(term))
stop("term must be of class call")
if (term[[1]] == as.name("|"))
return(term)
if (length(term) == 2)
return(findbars(term[[2]]))
c(findbars(term[[2]]), findbars(term[[3]]))
}
retrms <- getREterms(frames = frames, formulae$formula)
getAnywhere(slashTerms)
slashTerms <- function (x)
{
if (!("/" %in% all.names(x)))
return(x)
if (x[[1]] != as.name("/"))
stop("unparseable formula for grouping factor")
list(slashTerms(x[[2]]), slashTerms(x[[3]]))
}
retrms <- getREterms(frames = frames, formulae$formula)
retrms
retrms$gfList
use.ssr <- (retrms$ssr && !control$useMatrix)
use.ssr
setLinks(rho, link)
getAnywhere(setLinks)
getAnywhere(STstart)
getAnywhere(par2ST)
par2ST <- function (STpar, STlist)
{
nc <- sapply(STlist, ncol)
asgn <- rep(1:length(nc), sapply(nc, function(qi) qi * (qi +
1)/2))
STparList <- split(STpar, asgn)
stopifnot(length(asgn) == length(ST2par(STlist)))
for (i in 1:length(STlist)) {
par <- STparList[[i]]
if (nc[i] > 1) {
diag(STlist[[i]]) <- par[1:nc[i]]
STlist[[i]][lower.tri(STlist[[i]])] <- par[-(1:nc[i])]
}
else {
STlist[[i]][] <- par
}
}
STlist
}
rho$ST <- STstart(rho$ST)
par2ST(as.vector(start[[2]]), rho$ST)
start[[2]]
unlist(start[[2]])
start[[2]] <- unlist(start[[2]])
par2ST(as.vector(start[[2]]), rho$ST)
startpp2
start[[2]]
rho$ST
rho.clm2clmm(rho = rho, retrms = retrms, ctrl = control$ctrl)
rho$ST <- STstart(rho$ST)
STstart <- function (STlist) par2ST(STconstraints(STlist), STlist)
rho$ST <- STstart(rho$ST)
rho$ST
rho$fepar <- fe.start(frames, link, threshold)
getAnywhere(fe.start)
fe.start <- function (frames, link, threshold)
{
fit <- with(frames, clm.fit(y = y, X = X, weights = wts,
offset = off, link = link, threshold = threshold))
unname(coef(fit))
}
rho$fepar <- fe.start(frames, link, threshold)
rho$fepar
getAnywhere(rho.clm2clmm)
rho.clm2clmm <- function (rho, retrms, ctrl)
{
rho$ctrl = ctrl
rho$Zt <- getZt(retrms$retrms)
rho$ST <- lapply(retrms$retrms, `[[`, "ST")
rho$allST1 <- all(sapply(rho$ST, ncol) == 1)
rho$L <- Cholesky(tcrossprod(crossprod(getLambda(rho$ST,
rho$dims$nlev.re), rho$Zt)), LDL = TRUE, super = FALSE,
Imult = 1)
rho$Niter <- 0L
rho$neval <- 0L
rho$u <- rho$uStart <- rep(0, rho$dims$q)
rho$.f <- if (package_version(packageDescription("Matrix")$Version) >
"0.999375-30")
2
else 1
}
rho.clm2clmm(rho = rho, retrms = retrms, ctrl = control$ctrl)
getCtrlArgs
getAnywhere(getCtrlArgs)
getCtrlArgs <- function (control, extras)
{
if (!is.list(control))
stop("'control' should be a list")
ctrl.args <- if (setequal(names(control), names(clmm.control())))
c(extras, control["method"], control["useMatrix"], control$ctrl,
control$optCtrl)
else c(extras, control)
which.trace <- which(names(ctrl.args) == "trace")
trace.sum <- sum(unlist(ctrl.args[which.trace]))
if (trace.sum)
ctrl.args <- ctrl.args[-which.trace]
ctrl.args <- ctrl.args[!duplicated(names(ctrl.args))]
if (trace.sum >= 1)
ctrl.args$trace <- 1
if (trace.sum >= 2 || trace.sum <= -1)
ctrl.args$trace <- -1
do.call("clmm.control", ctrl.args)
}
control <- getCtrlArgs(control, list(...))
control <- list
control <- list()
control <- getCtrlArgs(control, list(...))
control <- getCtrlArgs(control))
control <- getCtrlArgs(control)
control <- getCtrlArgs(control, list())
control
rho.clm2clmm(rho = rho, retrms = retrms, ctrl = control$ctrl)
getAnywhere(getZt)
getZt <-
function (retrms)
{
ZtList <- lapply(retrms, "[[", "Zt")
Zt <- do.call(rbind, ZtList)
Zt@Dimnames <- vector("list", 2)
Zt
}
rho.clm2clmm(rho = rho, retrms = retrms, ctrl = control$ctrl)
getAnywere(Cholesly)
getAnywhere(Cholesly)
getAnywhere(Cholesky)
library(Matrix)
rho.clm2clmm(rho = rho, retrms = retrms, ctrl = control$ctrl)
getAnywhere(getLambda)
lambda <- function (ST, nlev)
{
.local <- function(ST, nlev) {
if (ncol(ST) == 1)
.symDiagonal(n = nlev, x = rep(as.vector(ST[1, 1]),
nlev))
else kronecker(as(ST, "sparseMatrix"), .symDiagonal(n = nlev))
}
stopifnot(length(ST) == length(nlev))
res <- if (length(ST) == 1)
.local(ST[[1]], nlev)
else .bdiag(lapply(seq_along(ST), function(i) .local(ST[[i]],
nlev[i])))
if (all(sapply(ST, ncol) == 1))
as(res, "diagonalMatrix")
else as(res, "CsparseMatrix")
}
rho.clm2clmm(rho = rho, retrms = retrms, ctrl = control$ctrl)
getLambda <- function (ST, nlev)
{
.local <- function(ST, nlev) {
if (ncol(ST) == 1)
.symDiagonal(n = nlev, x = rep(as.vector(ST[1, 1]),
nlev))
else kronecker(as(ST, "sparseMatrix"), .symDiagonal(n = nlev))
}
stopifnot(length(ST) == length(nlev))
res <- if (length(ST) == 1)
.local(ST[[1]], nlev)
else .bdiag(lapply(seq_along(ST), function(i) .local(ST[[i]],
nlev[i])))
if (all(sapply(ST, ncol) == 1))
as(res, "diagonalMatrix")
else as(res, "CsparseMatrix")
}
rho.clm2clmm(rho = rho, retrms = retrms, ctrl = control$ctrl)
setLinks(rho, link)
rho$dims <- getDims(frames = frames, ths = ths, retrms = retrms)
getAnywhere(getDims)
getDims <- function (frames, ths, retrms)
{
dims <- retrms$dims
dims$n <- sum(frames$wts > 0)
dims$nbeta <- ncol(frames$X) - 1
dims$nalpha <- ths$nalpha
dims$nfepar <- dims$nalpha + dims$nbeta
dims
}
rho$dims <- getDims(frames = frames, ths = ths, retrms = retrms)
rho$dims
rho.clm2clmm.ssr(rho = rho, retrms = retrms, ctrl = control$ctrl)
rho.clm2clmm(rho = rho, retrms = retrms, ctrl = control$ctrl)
rho$fepar <- fe.start(frames, link, threshold)
rho$ST
STstart(rho$ST)
getAnywhere(STconstraints)
STconstraints <-
function (STlist)
{
nc <- sapply(STlist, ncol)
unlist(lapply(nc, function(qi) {
c(rep(1L, qi), rep(0L, qi * (qi - 1)/2))
}))
}
STstart(rho$ST)
ST2par <- function (STpar, STlist)
{
nc <- sapply(STlist, ncol)
asgn <- rep(1:length(nc), sapply(nc, function(qi) qi * (qi +
1)/2))
STparList <- split(STpar, asgn)
stopifnot(length(asgn) == length(ST2par(STlist)))
for (i in 1:length(STlist)) {
par <- STparList[[i]]
if (nc[i] > 1) {
diag(STlist[[i]]) <- par[1:nc[i]]
STlist[[i]][lower.tri(STlist[[i]])] <- par[-(1:nc[i])]
}
else {
STlist[[i]][] <- par
}
}
STlist
}
STstart(rho$ST)
par2ST(as.vector(start[[2]]), rho$ST)
rho$ST
as.vector(start[[2]])
par2ST(as.vector(start[[2]]), rho$ST
)
getAnywhere(par2ST)
getAnywhere(par2ST)[2]
par2ST <- function (STpar, STlist)
{
nc <- sapply(STlist, ncol)
asgn <- rep(1:length(nc), sapply(nc, function(qi) qi * (qi +
1)/2))
STparList <- split(STpar, asgn)
stopifnot(length(asgn) == length(ST2par(STlist)))
for (i in 1:length(STlist)) {
par <- STparList[[i]]
if (nc[i] > 1) {
diag(STlist[[i]]) <- par[1:nc[i]]
STlist[[i]][lower.tri(STlist[[i]])] <- par[-(1:nc[i])]
}
else {
STlist[[i]][] <- par
}
}
STlist
}
par2ST(as.vector(start[[2]]), rho$ST
)
rho$ST
par2ST
sapply(rho$ST, ncol)
asgn <- rep(1:length(nc), sapply(nc, function(qi) qi * (qi +
1)/2))
nc <- sapply(rho$ST, ncol)
asgn <- rep(1:length(nc), sapply(nc, function(qi) qi * (qi +
1)/2))
asgn
STparList <- split(STpar, asgn)
STparList <- split(start[[2]], asgn)
STparList
fitted
n_re <- length(fitted$ST)
wald_se <- sqrt(diag(vcov(fitted)))
wald_se <- wald_se[(length(wald_se) - n_re + 1):length(wald_se)]
mu <- log(unlist(fitted$ST))
x_profile <- matrix(nrow = n_steps, ncol = n_re)
for(i in 1:n_re){
x_profile[, i] <- seq(mu[i] - qnorm(1 - alpha/2) * wald_se[i],
mu[i] + qnorm(1 - alpha/2) * wald_se[i],
length.out = n_steps)
}
y_profile <- matrix(nrow = n_steps, ncol = n_re)
i <- 1
mu_start    <- mu
j <- 1
mu_start[i]   <- x_profile[j, i]
start         <- list(fitted$coefficients, mu_start)
start
fit_prof      <- update(fitted, start = start, eval.max = 1)
fit_prof
fit_prof      <- update(fitted, start = start, eval.max = 2)
fit_prof
fit_prof      <- update(fitted, start = start, eval.max = 600)
fit_prof
start
start         <- list(fitted$coefficients, exp(mu_start))
fit_prof      <- update(fitted, start = start, eval.max = 600)
mu_start[i]   <- x_profile[j, i]
start         <- list(fitted$coefficients, exp(mu_start))
start
fit_prof      <- update(fitted, start = start, eval.max = 1)
fit_prof
y_profile[j, i] <- sign(mu[i] - x_profile[j, i]) * sqrt(-2 * (fit_prof$logLik - fitted$logLik))
for(i in 1:n_re){
mu_start    <- mu
for(j in 1:n_steps){
mu_start[i]   <- x_profile[j, i]
start         <- list(fitted$coefficients, exp(mu_start))
fit_prof      <- update(fitted, start = start, eval.max = 1)
y_profile[j, i] <- sign(mu[i] - x_profile[j, i]) * sqrt(-2 * (fit_prof$logLik - fitted$logLik))
}
}
y_profile
plot(y_profile[, 1])
plot(y_profile[, 1], type = "l")
plot(y_profile[, 2], type = "l")
plot(x_profile[, 1], y_profile[, 2], type = "l")
